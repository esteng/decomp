

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Querying UDS Graphs &mdash; Decomp 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Serializing the UDS dataset" href="serializing.html" />
    <link rel="prev" title="Reading the UDS dataset" href="reading.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Decomp
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="quick-start.html">Quick Start</a></li>
<li class="toctree-l2"><a class="reference internal" href="reading.html">Reading the UDS dataset</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Querying UDS Graphs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pre-compiled-queries">Pre-compiled queries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#custom-queries">Custom queries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="serializing.html">Serializing the UDS dataset</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../data/index.html">Dataset Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../package/index.html">Package Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Decomp</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Tutorials</a> &raquo;</li>
        
      <li>Querying UDS Graphs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/tutorial/querying.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="querying-uds-graphs">
<h1>Querying UDS Graphs<a class="headerlink" href="#querying-uds-graphs" title="Permalink to this headline">¶</a></h1>
<p>Decomp provides a rich array of methods for querying UDS graphs. Nearly all of these methods are built on top of the <a class="reference external" href="../package/decomp.semantics.uds.html#decomp.semantics.uds.UDSGraph.query">UDSGraph.query</a> instance method. This method accepts arbitrary SPARQL 1.1 queries, either as strings or as precompiled <a class="reference external" href="https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.plugins.sparql.html#rdflib.plugins.sparql.sparql.Query">Query</a> objects built using RDFlib’s <a class="reference external" href="https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.plugins.sparql.html?highlight=preparequery#rdflib.plugins.sparql.processor.prepareQuery">prepareQuery</a>.</p>
<div class="section" id="pre-compiled-queries">
<h2>Pre-compiled queries<a class="headerlink" href="#pre-compiled-queries" title="Permalink to this headline">¶</a></h2>
<p>For many use cases, the various instance attributes and methods for
accessing nodes, edges, and their attributes in the UDS graphs will
likely be sufficient; there is no need to directly use <code class="docutils literal notranslate"><span class="pre">query</span></code>. For
example, to get a dictionary mapping identifiers for syntax nodes in
the UDS graph to their attributes, you can use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">uds</span><span class="p">[</span><span class="s2">&quot;ewt-train-12&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">syntax_nodes</span>
</pre></div>
</div>
<p>To get a dictionary mapping identifiers for semantics nodes in the UDS
graph to their attributes, you can use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">uds</span><span class="p">[</span><span class="s2">&quot;ewt-train-12&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">semantics_nodes</span>
</pre></div>
</div>
<p>To get a dictionary mapping identifiers for semantics edges (tuples of
node identifiers) in the UDS graph to their attributes, you can use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">uds</span><span class="p">[</span><span class="s2">&quot;ewt-train-12&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">semantics_edges</span><span class="p">()</span>
</pre></div>
</div>
<p>To get a dictionary mapping identifiers for semantics edges (tuples of
node identifiers) in the UDS graph involving the predicate headed by
the 7th token to their attributes, you can use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">uds</span><span class="p">[</span><span class="s2">&quot;ewt-train-12&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">semantics_edges</span><span class="p">(</span><span class="s1">&#39;ewt-train-12-semantics-pred-7&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To get a dictionary mapping identifiers for syntax edges (tuples of
node identifiers) in the UDS graph to their attributes, you can use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">uds</span><span class="p">[</span><span class="s2">&quot;ewt-train-12&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">syntax_edges</span><span class="p">()</span>
</pre></div>
</div>
<p>And to get a dictionary mapping identifiers for syntax edges (tuples
of node identifiers) in the UDS graph involving the node for the 7th
token to their attributes, you can use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">uds</span><span class="p">[</span><span class="s2">&quot;ewt-train-12&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">syntax_edges</span><span class="p">(</span><span class="s1">&#39;ewt-train-12-syntax-7&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>There are also methods for accessing relationships between semantics
and syntax nodes. For example, you can get a tuple of the ordinal
position for the head syntax node in the UDS graph that maps of the
predicate headed by the 7th token in the corresponding sentence to a
list of the form and lemma attributes for that token, you can use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">uds</span><span class="p">[</span><span class="s2">&quot;ewt-train-12&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="s1">&#39;ewt-train-12-semantics-pred-7&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">,</span> <span class="s1">&#39;lemma&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>And if you want the same information for every token in the span, you
can use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">uds</span><span class="p">[</span><span class="s2">&quot;ewt-train-12&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">span</span><span class="p">(</span><span class="s1">&#39;ewt-train-12-semantics-pred-7&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">,</span> <span class="s1">&#39;lemma&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>This will return a dictionary mapping ordinal position for syntax
nodes in the UDS graph that make of the predicate headed by the 7th
token in the corresponding sentence to a list of the form and lemma
attributes for the corresponding tokens.</p>
</div>
<div class="section" id="custom-queries">
<h2>Custom queries<a class="headerlink" href="#custom-queries" title="Permalink to this headline">¶</a></h2>
<p>Where the above methods generally turn out to be insufficient is in
selecting nodes and edges on the basis of (combinations of their
attributes). This is where having the full power of SPARQL comes in
handy.</p>
<p>For example, if you were interested in extracting only predicates
referring to events that likely happened and likely lasted for
minutes, you could use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">querystr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">           SELECT ?pred</span>
<span class="s2">           WHERE { ?pred &lt;domain&gt; &lt;semantics&gt; ;</span>
<span class="s2">                         &lt;type&gt; &lt;predicate&gt; ;</span>
<span class="s2">                         &lt;factuality-factual&gt; ?factual ;</span>
<span class="s2">                         &lt;time-dur-minutes&gt; ?duration</span>
<span class="s2">                         FILTER ( ?factual &gt; 0 &amp;&amp; ?duration &gt; 0 )</span>
<span class="s2">                 }</span>
<span class="s2">           &quot;&quot;&quot;</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="n">gid</span><span class="p">:</span> <span class="n">graph</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">querystr</span><span class="p">,</span> <span class="n">query_type</span><span class="o">=</span><span class="s1">&#39;node&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">gid</span><span class="p">,</span> <span class="n">graph</span> <span class="ow">in</span> <span class="n">uds</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">query_type</span></code> parameter is set to <code class="docutils literal notranslate"><span class="pre">'node'</span></code>. This setting means that a dictionary mapping node identifiers to node attribute values will be returned. If no such query type is passed, an RDFLib <a class="reference external" href="https://rdflib.readthedocs.io/en/stable/apidocs/rdflib.html#rdflib.query.Result">Result</a> object will be returned, which you will need to postprocess yourself. This is necessary if, for instance, you are making a <code class="docutils literal notranslate"><span class="pre">CONSTRUCT</span></code>, <code class="docutils literal notranslate"><span class="pre">ASK</span></code>, or <code class="docutils literal notranslate"><span class="pre">DESCRIBE</span></code> query.</p>
<p>Constraints can also make reference to node and edge attributes of other nodes. For instance, if you were interested in extracting all predicates referring to events that are likely spatiotemporally delimited and have at least one spatiotemporally delimited participant that was volitional in the event, you could use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">querystr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">           SELECT DISTINCT ?node</span>
<span class="s2">           WHERE { ?node ?edge ?arg ;</span>
<span class="s2">                         &lt;domain&gt; &lt;semantics&gt; ;</span>
<span class="s2">                         &lt;type&gt;   &lt;predicate&gt; ;</span>
<span class="s2">                         &lt;genericity-pred-particular&gt; ?predparticular</span>
<span class="s2">                         FILTER ( ?predparticular &gt; 0 ) .</span>
<span class="s2">                   ?arg  &lt;domain&gt; &lt;semantics&gt; ;</span>
<span class="s2">                         &lt;type&gt;   &lt;argument&gt;  ;</span>
<span class="s2">                         &lt;genericity-arg-particular&gt; ?argparticular</span>
<span class="s2">                         FILTER ( ?argparticular &gt; 0 ) .</span>
<span class="s2">                   ?edge &lt;protoroles-volition&gt; ?volition</span>
<span class="s2">                         FILTER ( ?volition &gt; 0 ) .</span>
<span class="s2">                 }</span>
<span class="s2">           &quot;&quot;&quot;</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="n">gid</span><span class="p">:</span> <span class="n">graph</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">querystr</span><span class="p">,</span> <span class="n">query_type</span><span class="o">=</span><span class="s1">&#39;node&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">gid</span><span class="p">,</span> <span class="n">graph</span> <span class="ow">in</span> <span class="n">uds</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</pre></div>
</div>
<p>Disjunctive constraints are also possible. For instance, for the last query, if you were interested in either volitional or sentient arguments, you could use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">querystr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">           SELECT DISTINCT ?node</span>
<span class="s2">           WHERE { ?node ?edge ?arg ;</span>
<span class="s2">                         &lt;domain&gt; &lt;semantics&gt; ;</span>
<span class="s2">                         &lt;type&gt;   &lt;predicate&gt; ;</span>
<span class="s2">                         &lt;genericity-pred-particular&gt; ?predparticular</span>
<span class="s2">                         FILTER ( ?predparticular &gt; 0 ) .</span>
<span class="s2">                   ?arg  &lt;domain&gt; &lt;semantics&gt; ;</span>
<span class="s2">                         &lt;type&gt;   &lt;argument&gt;  ;</span>
<span class="s2">                         &lt;genericity-arg-particular&gt; ?argparticular</span>
<span class="s2">                         FILTER ( ?argparticular &gt; 0 ) .</span>
<span class="s2">                   { ?edge &lt;protoroles-volition&gt; ?volition</span>
<span class="s2">                           FILTER ( ?volition &gt; 0 )</span>
<span class="s2">                   } UNION</span>
<span class="s2">                   { ?edge &lt;protoroles-sentient&gt; ?sentient</span>
<span class="s2">                           FILTER ( ?sentient &gt; 0 )</span>
<span class="s2">                   }</span>
<span class="s2">                 }</span>
<span class="s2">           &quot;&quot;&quot;</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="n">gid</span><span class="p">:</span> <span class="n">graph</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">querystr</span><span class="p">,</span> <span class="n">query_type</span><span class="o">=</span><span class="s1">&#39;node&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">gid</span><span class="p">,</span> <span class="n">graph</span> <span class="ow">in</span> <span class="n">uds</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</pre></div>
</div>
<p>Beyond returning node attributes based on complex constraints, you can also return edge attributes. For instance, for the last query, if you were interested in all the attributes of edges connecting predicates and arguments satisfying the constraints of the last query, you could simply change which variable is bound by <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> and set <code class="docutils literal notranslate"><span class="pre">query_type</span></code> to <code class="docutils literal notranslate"><span class="pre">'edge'</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">querystr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">           SELECT ?edge</span>
<span class="s2">           WHERE { ?node ?edge ?arg ;</span>
<span class="s2">                         &lt;domain&gt; &lt;semantics&gt; ;</span>
<span class="s2">                         &lt;type&gt;   &lt;predicate&gt; ;</span>
<span class="s2">                         &lt;genericity-pred-particular&gt; ?predparticular</span>
<span class="s2">                         FILTER ( ?predparticular &gt; 0 ) .</span>
<span class="s2">                   ?arg  &lt;domain&gt; &lt;semantics&gt; ;</span>
<span class="s2">                         &lt;type&gt;   &lt;argument&gt;  ;</span>
<span class="s2">                         &lt;genericity-arg-particular&gt; ?argparticular</span>
<span class="s2">                         FILTER ( ?argparticular &gt; 0 ) .</span>
<span class="s2">                   { ?edge &lt;protoroles-volition&gt; ?volition</span>
<span class="s2">                           FILTER ( ?volition &gt; 0 )</span>
<span class="s2">                   } UNION</span>
<span class="s2">                   { ?edge &lt;protoroles-sentient&gt; ?sentient</span>
<span class="s2">                           FILTER ( ?sentient &gt; 0 )</span>
<span class="s2">                   }</span>
<span class="s2">                 }</span>
<span class="s2">           &quot;&quot;&quot;</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="n">gid</span><span class="p">:</span> <span class="n">graph</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">querystr</span><span class="p">,</span> <span class="n">query_type</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">gid</span><span class="p">,</span> <span class="n">graph</span> <span class="ow">in</span> <span class="n">uds</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="serializing.html" class="btn btn-neutral float-right" title="Serializing the UDS dataset" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="reading.html" class="btn btn-neutral float-left" title="Reading the UDS dataset" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Aaron Steven White

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>